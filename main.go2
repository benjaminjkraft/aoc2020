package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"sort"
	"strconv"
)

type solution[T any] struct {
	parse        func(string) (T, error)
	part1, part2 func(T) (int, error)
}

func (s solution[T]) solve(input string) (int, int, error) {
	parsed, err := s.parse(input)
	if err != nil {
		return -1, -1, fmt.Errorf("invalid input: %w", err)
	}

	ans1, err := s.part1(parsed)
	if err != nil {
		return -1, -1, fmt.Errorf("part 1 failed: %w", err)
	}

	ans2, err := s.part2(parsed)
	if err != nil {
		return -1, -1, fmt.Errorf("part 2 failed: %w", err)
	}
	return ans1, ans2, nil
}

type solvable interface {
	solve(string) (int, int, error)
}

var solutions = map[int]solvable{
	1: solution[[]int]{lineParser(strconv.Atoi), day01a, day01b},
	2: solution[[]password]{lineParser(parsePassword), day02a, day02b},
	3: solution[[][]bool]{lineParser(parseTree), day03a, day03b},
	4: solution[[]passport]{parsePassports, day04a, day04b},
	5: solution[[]int]{lineParser(parseSeat), day05a, day05b},
}

func run(day int) {
	input, err := ioutil.ReadFile(fmt.Sprintf("input/%v", day))
	if err != nil {
		fmt.Println(fmt.Errorf("invalid input: %v", err))
		os.Exit(1)
	}

	ans1, ans2, err := solutions[day].solve(string(input))
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	fmt.Println(ans1)
	fmt.Println(ans2)
}

func main() {
	if len(os.Args) > 1 {
		day, err := strconv.Atoi(os.Args[1])
		if err != nil {
			fmt.Println(fmt.Errorf("invalid argument: %v", err))
			os.Exit(1)
		}

		run(day)
	} else {
		days := Keys(solutions)
		sort.Ints(days)
		for _, day := range days {
			fmt.Printf("=== day %02d ===\n", day)
			run(day)
		}
	}
}
