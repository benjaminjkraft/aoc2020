package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"sort"
	"strconv"
)

type solution[T any] struct {
	parse        func(string) (T, error)
	part1, part2 func(T) (int, error)
}

func (s solution[T]) solve(input string) (int, int, error) {
	parsed, err := s.parse(input)
	if err != nil {
		return -1, -1, fmt.Errorf("invalid input: %w", err)
	}

	ans1, err := s.part1(parsed)
	if err != nil {
		return -1, -1, fmt.Errorf("part 1 failed: %w", err)
	}

	ans2, err := s.part2(parsed)
	if err != nil {
		return -1, -1, fmt.Errorf("part 2 failed: %w", err)
	}
	return ans1, ans2, nil
}

type solvable interface {
	solve(string) (int, int, error)
}

var solutions = map[int]solvable{
	1:  solution[[]int]{lineParser(strconv.Atoi), day01a, day01b},
	2:  solution[[]password]{lineParser(parsePassword), day02a, day02b},
	3:  solution[[][]bool]{lineParser(parseTree), day03a, day03b},
	4:  solution[[]passport]{blockParser(parsePassport), day04a, day04b},
	5:  solution[[]int]{lineParser(parseSeat), day05a, day05b},
	6:  solution[[]customs]{blockParser(parseCustoms), day06a, day06b},
	7:  solution[bagGraph]{parseBagGraph, day07a, day07b},
	8:  solution[[]instruction]{lineParser(parseInstruction), day08a, day08b},
	9:  solution[[]int]{lineParser(strconv.Atoi), day09a, day09b},
	10: solution[[]int]{lineParser(strconv.Atoi), day10a, day10b},
	11: solution[[][]byte]{lineParser(strtobytes), day11a, day11b},
}

func run(day int) {
	input, err := ioutil.ReadFile(fmt.Sprintf("input/%v", day))
	if err != nil {
		fmt.Println(fmt.Errorf("invalid input: %v", err))
		os.Exit(1)
	}

	ans1, ans2, err := solutions[day].solve(string(input))
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	fmt.Println(ans1)
	fmt.Println(ans2)
}

func main() {
	if len(os.Args) > 1 {
		day, err := strconv.Atoi(os.Args[1])
		if err != nil {
			fmt.Println(fmt.Errorf("invalid argument: %v", err))
			os.Exit(1)
		}

		run(day)
	} else {
		days := Keys(solutions)
		sort.Ints(days)
		for _, day := range days {
			fmt.Printf("=== day %02d ===\n", day)
			run(day)
		}
	}
}
