package main

import (
	"strings"
)

type Pair[T, U any] struct {
	First  T
	Second U
}

func Keys[K comparable, V any](m map[K]V) []K {
	ret := make([]K, 0, len(m))
	for k := range m {
		ret = append(ret, k)
	}
	return ret
}

func Remove[T comparable](xs []T, x T) []T {
	m := make([]T, 0, len(xs))
	for _, y := range xs {
		if y != x {
			m = append(m, y)
		}
	}
	return m
}

func ItemsEqual[T comparable](xs, ys []T) bool {
	m := make(map[T]int, len(xs))
	for _, x := range xs {
		m[x]++
	}
	for _, y := range ys {
		m[y]--
	}
	for _, count := range m {
		if count != 0 {
			return false
		}
	}
	return true
}

func Map[T, U any](f func(T) U, xs []T) []U {
	ret := make([]U, len(xs))
	for i, x := range xs {
		ret[i] = f(x)
	}
	return ret
}

func MapE[T, U any](f func(T) (U, error), xs []T) ([]U, error) {
	var err error
	ret := make([]U, len(xs))
	for i, x := range xs {
		ret[i], err = f(x)
		if err != nil {
			return nil, err
		}
	}
	return ret, nil
}

func ToMap[K comparable, V any](pairs []Pair[K, V]) map[K]V {
	ret := make(map[K]V, len(pairs))
	for _, p := range pairs {
		ret[p.First] = p.Second
	}
	return ret
}

func count[T any](f func(T) bool, xs []T) int {
	ret := 0
	for _, x := range xs {
		if f(x) {
			ret++
		}
	}
	return ret
}

func filter[T any](f func(T) bool, xs []T) []T {
	ret := make([]T, 0, len(xs))
	for _, x := range xs {
		if f(x) {
			ret = append(ret, x)
		}
	}
	return ret
}

func All[T any](f func(T) bool, xs []T) bool {
	for _, x := range xs {
		if !f(x) {
			return false
		}
	}
	return true
}

func Any[T any](f func(T) bool, xs []T) bool {
	for _, x := range xs {
		if f(x) {
			return true
		}
	}
	return false
}

func Contains[T comparable](xs []T, x T) bool {
	return Any(func(t T) bool { return x == t }, xs)
}

func nonzero[T comparable](xs []T) []T {
	var z T
	return filter(func(x T) bool { return x != z }, xs)
}

func lineParser[T any](f func(string) (T, error)) func(string) ([]T, error) {
	return func(input string) ([]T, error) {
		return MapE(f, nonzero(strings.Split(input, "\n")))
	}
}

func max(xs ...int) int {
	if len(xs) == 0 {
		panic("max of no args")
	}

	m := xs[0]
	for _, x := range xs[1:] {
		if x > m {
			m = x
		}
	}
	return m
}

func min(xs ...int) int {
	if len(xs) == 0 {
		panic("min of no args")
	}

	m := xs[0]
	for _, x := range xs[1:] {
		if x < m {
			m = x
		}
	}
	return m
}
